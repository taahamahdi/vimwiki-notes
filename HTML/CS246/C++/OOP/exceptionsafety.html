<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="../../../style.css">
<title>exceptionsafety</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<div id="Exception Safety"><h1 id="Exception Safety">Exception Safety</h1></div>

<p>
Consider:
</p>
<pre cpp>
void f() {
	MyClass mc;
	MyClass *p = new MyClass;
	g();
	delete p;
}
</pre>
<ul>
<li>
No leaks -- but what if <code>g</code> throws?

<ul>
<li>
What is guaranteed?

<ul>
<li>
During stack unwinding, all stack-allocated data is cleared up

<ul>
<li>
Destructors run and memory is reclaimed

</ul>
<li>
Heap-allocated memory is not destroyed

</ul>
<li>
If <code>g</code> throws, <code>*p</code> is leaked (<code>mc</code> is not)

</ul>
<li>
We must make sure no memory is leaked to prevent future issues (what if <code>f</code> is called a thousand times?)
<pre cpp>
void f() {
	MyClass mc;
	MyClass *p = new MyClass;
	try {
		g();
	}
	catch (...) {
		delete p;
		throw;
	}
}
</pre>

<ul>
<li>
This implementation is ugly and error-prone, and also contains code duplication

<li>
How else can we guarantee that something (i.e. <code>delete p</code>) will happen no matter how we exit <code>f</code> (whether normal or via exception)?

</ul>
<li>
In some languages, there are "finally" clauses that guarantee certain final actions

<ul>
<li>
Not in C++

</ul>
<li>
Only thing you can count on in C++ -- destructors for stack-allocated data will run

<ul>
<li>
Therefore use stack-allocated data with destructors as much as possible

<ul>
<li>
(Use the guarantee to your advantage)

</ul>
</ul>
<li>
C++ Idiom: <span id="Exception Safety-RAII"></span><strong id="RAII">RAII</strong> -- Resource Acquisition Is Initialization

<ul>
<li>
Every resource should be wrapped in a stack-allocated object, whose destructor deletes it

<ul>
<li>
<span id="Exception Safety-Example"></span><strong id="Example">Example</strong>: Files
<pre cpp>
{
	ifstream f{"file"}; // Acquiring the resource ("file") == initializing the object (f)
	...
	// The file is guaranteed to be released when f is popped from the stack
	// f's destructor runs
}
</pre>

</ul>
<li>
This can be done with dynamic memory

<li>
<code>class std::unique_ptr&lt;T&gt;</code> (by <code>#include &lt;memory&gt;</code>)

<ul>
<li>
Takes a <code>T*</code> in the constructor

<li>
The destructor will delete the pointer

<li>
In between, can dereference it, just like a pointer
<pre cpp>
void f() {
	MyClass mc;
	std::unique_ptr&lt;MyClass&gt; p{new MyClass};
	g();
}

// Alternative method (completely equivalent)
void f() {
	MyClass mc;
	auto p = std::make_unique&lt;MyClass&gt;();
	// Arguments to constructor go in make_unique parentheses
	// auto type is unique_ptr&lt;MyClass&gt;
	g();
}
</pre>

</ul>
<li>
No leaks. Guaranteed.

<li>
<span id="Exception Safety-Difficulty"></span><strong id="Difficulty">Difficulty</strong>:
<pre cpp>
class C {...};
unique_ptr&lt;C&gt; p { new C{...} };
unique_ptr&lt;C&gt; q = p;
// Does not compile
</pre>

<ul>
<li>
What happens when a <code>unique_ptr</code> is copied? -- Don't want to delete the same pointer twice!

<ul>
<li>
Instead -- copying is disabled for <code>unique_ptr</code>s

<li>
They can only be moved

</ul>
</ul>
</ul>
<li>
<span id="Exception Safety-Sample implementation"></span><strong id="Sample implementation">Sample implementation</strong>:
<pre cpp>
template&lt;typename T&gt; class unique_ptr {
	T *ptr;
public:
	explicit unique_ptr(T *p) ptr{p} {}
	~unique_ptr() { delete ptr; } 
	// Disable copy constructor
	unique_ptr(const unique_ptr&lt;T&gt; &amp;other) = delete;
	// Copy assignment operator is automatically disabled
	unique_ptr &amp;operator=(const unique_ptr&lt;T&gt; &amp;other) = delete;
	unique_ptr(unique_ptr&lt;T&gt; &amp;&amp;other): ptr{other.ptr} { other.ptr = nullptr; }
	unique_ptr&lt;T&gt; &amp;operator=(unique_ptr&lt;T&gt; &amp;&amp;other) {
		std::swap(ptr, other.ptr);
		return *this;
	}
	T &amp;operator*() { return *ptr; }
};
</pre>

<li>
If you need to be able to copy pointers

<ul>
<li>
First answer the question of <em>ownership</em>

<ul>
<li>
Who will own the resource? Who will have responsibility for freeing it?

<ul>
<li>
That pointer should be <code>unique_ptr</code>

<ul>
<li>
All other pointers can be raw pointers

<li>
(Fetch the underlying raw pointer with <code>p.get()</code>)

</ul>
</ul>
</ul>
</ul>
<li>
If there is true shared ownership (i.e. any of the several pointers might free the resource) -- use <code>std::shared_ptr</code>

</ul>

</body>
</html>
