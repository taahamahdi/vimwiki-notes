= Exception Safety =

Consider:
{{{cpp
void f() {
	MyClass mc;
	MyClass *p = new MyClass;
	g();
	delete p;
}
}}}
* No leaks -- but what if `g` throws?
	* What is guaranteed?
		* During stack unwinding, all stack-allocated data is cleared up
			* Destructors run and memory is reclaimed
		* Heap-allocated memory is not destroyed
	* If `g` throws, `*p` is leaked (`mc` is not)
* We must make sure no memory is leaked to prevent future issues (what if `f` is called a thousand times?)
{{{cpp
void f() {
	MyClass mc;
	MyClass *p = new MyClass;
	try {
		g();
	}
	catch (...) {
		delete p;
		throw;
	}
}
}}}
	* This implementation is ugly and error-prone, and also contains code duplication
	* How else can we guarantee that something (i.e. `delete p`) will happen no matter how we exit `f` (whether normal or via exception)?
* In some languages, there are "finally" clauses that guarantee certain final actions
	* Not in C++
* Only thing you can count on in C++ -- destructors for stack-allocated data will run
	* Therefore use stack-allocated data with destructors as much as possible
		* (Use the guarantee to your advantage)
* C++ Idiom: *RAII* -- Resource Acquisition Is Initialization
	* Every resource should be wrapped in a stack-allocated object, whose destructor deletes it
		* *Example*: Files
{{{cpp
{
	ifstream f{"file"}; // Acquiring the resource ("file") == initializing the object (f)
	...
	// The file is guaranteed to be released when f is popped from the stack
	// f's destructor runs
}
}}}
	* This can be done with dynamic memory
	* `class std::unique_ptr<T>` (by `#include <memory>`)
		* Takes a `T*` in the constructor
		* The destructor will delete the pointer
		* In between, can dereference it, just like a pointer
{{{cpp
void f() {
	MyClass mc;
	std::unique_ptr<MyClass> p{new MyClass};
	g();
}

// Alternative method (completely equivalent)
void f() {
	MyClass mc;
	auto p = std::make_unique<MyClass>();
	// Arguments to constructor go in make_unique parentheses
	// auto type is unique_ptr<MyClass>
	g();
}
}}}
	* No leaks. Guaranteed.
	* *Difficulty*:
{{{cpp
class C {...};
unique_ptr<C> p { new C{...} };
unique_ptr<C> q = p;
// Does not compile
}}}
		* What happens when a `unique_ptr` is copied? -- Don't want to delete the same pointer twice!
			* Instead -- copying is disabled for `unique_ptr`s
			* They can only be moved
* *Sample implementation*:
{{{cpp
template<typename T> class unique_ptr {
	T *ptr;
public:
	explicit unique_ptr(T *p) ptr{p} {}
	~unique_ptr() { delete ptr; } 
	// Disable copy constructor
	unique_ptr(const unique_ptr<T> &other) = delete;
	// Copy assignment operator is automatically disabled
	unique_ptr &operator=(const unique_ptr<T> &other) = delete;
	unique_ptr(unique_ptr<T> &&other): ptr{other.ptr} { other.ptr = nullptr; }
	unique_ptr<T> &operator=(unique_ptr<T> &&other) {
		std::swap(ptr, other.ptr);
		return *this;
	}
	T &operator*() { return *ptr; }
};
}}}
* If you need to be able to copy pointers
	* First answer the question of _ownership_
		* Who will own the resource? Who will have responsibility for freeing it?
			* That pointer should be `unique_ptr`
				* All other pointers can be raw pointers
				* (Fetch the underlying raw pointer with `p.get()`)
* If there is true shared ownership (i.e. any of the several pointers might free the resource) -- use `std::shared_ptr`
